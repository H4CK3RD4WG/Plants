using UnityEngine;
using System.Collections;
using Vectrosity;

//The selection line ignores the depth of other vector lines in the scene; namely, we have no sense of
//depth when attempting to select among the branches of L_systems because there is no way to tell when
//the selection line should be in front or behind a given line. Thus we cannot set the depth accordingly.
//Vectrosity is supposed to do this manually by setting depths in the order line rendering functions are
//called, but the selection line is re-rendered every frame and is thus on top of every other line in the
//scene. There is no immediately apparent solution to this.
public class selectionLine : MonoBehaviour {

	public VectorLine line;
	private GameObject targetNode;
	private RaycastHit trajectory;
	private float maxLineLength = 50.0f;
	private Ray orientation;
	private Vector3 currentTarget;
	private int formSelectionMask = 1 << 8; 	//Binary: 100000000
	private int leafSelectionMask = 1 << 9;
	private int flowerSelectionMask = 1 << 10;
	private int descriptionMask;
	private float questionTimer = 1;
	private float timer = 0;
	private bool questioning = false;
	private bool tutorial = false;
	private bool timerSet = false;

	private int selectionState = 0;			//We add a new selection state for descriptive Objectives
											//remember this
	private MeshRenderer lastCollided;
	public GameObject descriptionObjective;
	public GameObject plsLast; 
	private Parametric_L_System pls;
	// Use this for initialization
	void Awake()
	{

	}

	void Start () 
	{
		questionGenerator.cycleImage (selectionState);
		plsLast = null;
		descriptionMask = formSelectionMask + 1;
		orientation = new Ray (this.transform.position, -this.transform.forward);
		targetNode = Instantiate(Resources.Load ("Prefabs/Other/TargetNode")) as GameObject;
	}
	
	// Update is called once per frame
	void Update () 
	{
		clearLine ();
		orientation = new Ray (this.transform.position, -this.transform.forward);

		if(objectivesInventory.IsDescribing() && plsLast != null)
		{
			//if(descriptionObjective != null)
			//	descriptionObjective.transform.position = transform.position;
			//Debug.Log ("Got the description part");
			//We use the new location data of plsLast with the defined drop off area to check if it
			//is in the zone. Then we perform an analysis of the components to see if they match the
			//ones generated by the descriptive objective.
			//Both of these function should be defined inside of the objectivesInventory script, made
			//public, and take a GameObject argument which will always be the PLSYS in question
			if(objectivesInventory.inDropOffArea(plsLast))
			{
				if(!objectivesInventory.checkDescriptiveObjective(plsLast))
				{
					if(!tutorial)
						pls.beginDecay();
				}
			}
			else if(questioning)
			{
				Debug.Log (plsLast.transform.position);
			}
		}
		if(questioning)
		{
			if(questionGenerator.answerResults())
			{
				if(!timerSet)
				{
					timerSet = true;
					timer = questionTimer;
				}
				else if(timer > 0)
					timer -= Time.deltaTime;
				else
				{
					if(selectionState == 0)
					{
						pls.formSelected = true;
						objectivesInventory.addGrowthForm(plsLast.tag);
					}
					else if(selectionState == 1)
					{
						pls.leavesSelected = true;
						objectivesInventory.addLeaf(plsLast.tag);
					}
					else if(selectionState == 2)
					{
						pls.flowersSelected = true;
						objectivesInventory.addFlower(plsLast.tag);
					}
					plsLast.tag = "Selected";
					questionGenerator.clearQuestion();
					questioning = false;
					timerSet = false;
				}
			}
			else if(!questionGenerator.questioning())
			{
				pls.beginDecay();
				plsLast = null;
				questioning = false;
			}
			else if(questionGenerator.replied())
			{
				if(!timerSet)
				{
					timerSet = true;
					timer = questionTimer;
				}
				timer -= Time.deltaTime;
				if(timer < 0)
				{
					timerSet = false;
					questionGenerator.clearQuestion();
				}
			}

		}
		else if(selectionState == 0)
		{
			if(Physics.Raycast(orientation, out trajectory, maxLineLength, formSelectionMask))
			{
				plsLast = trajectory.collider.gameObject.transform.parent.gameObject;
				pls = plsLast.GetComponent<Parametric_L_System>();

				if(pls.stopAnimating())
				{
					if(lastCollided != null)
						lastCollided.enabled = false;

					if(trajectory.collider.gameObject.tag == "Node")
					{
						currentTarget = orientation.origin+orientation.direction*trajectory.distance;
						
						line = VectorLine.SetRay3D
							(Color.red, orientation.origin, orientation.direction*trajectory.distance);

						lastCollided = trajectory.collider.gameObject.GetComponent<MeshRenderer>();
						lastCollided.enabled = true;

						if(Input.GetMouseButtonDown(0) || Input.GetButtonDown("SelectBeam"))
						{
							lastCollided = null;
							if(trajectory.collider.gameObject.tag != "Selected")
							{
								if(tutorial)
								{
									SendMessageUpwards("getNode");
									SendMessageUpwards("displayLesson", "Node");
								}
								trajectory.collider.gameObject.tag = "Selected";
								objectivesInventory.addGrowthForm("Node");
							}
						}
					}
					else if(!pls.formSelected && trajectory.collider.gameObject.name == "BasalForm")
					{
						currentTarget = orientation.origin+orientation.direction*trajectory.distance;
						
						line = VectorLine.SetRay3D
							(Color.red, orientation.origin, orientation.direction*trajectory.distance);
						
						if(Input.GetMouseButtonDown(0) || Input.GetButtonDown("SelectBeam"))
						{
							questionGenerator.createQuestion(plsLast.tag);
							questioning = true;
						}
					}
					else
					{
						currentTarget = orientation.origin+orientation.direction*maxLineLength;
						line = VectorLine.SetRay3D
							(Color.magenta, orientation.origin, maxLineLength*orientation.direction);
					}
				}
				else
				{
					currentTarget = orientation.origin+orientation.direction*maxLineLength;
					line = VectorLine.SetRay3D
						(Color.magenta, orientation.origin, maxLineLength*orientation.direction);
				}
			}
			else
			{
				currentTarget = orientation.origin+orientation.direction*maxLineLength;
				line = VectorLine.SetRay3D
					(Color.magenta, orientation.origin, maxLineLength*orientation.direction);
			}
		}
		else if(selectionState == 1)
		{


			if(Physics.Raycast(orientation, out trajectory, maxLineLength, leafSelectionMask))
			{
				plsLast = trajectory.collider.gameObject;
				pls = plsLast.GetComponentInParent<Parametric_L_System>();
				if(!pls.leavesSelected && pls.stopAnimating())
				{
					currentTarget = orientation.origin+orientation.direction*trajectory.distance;
					line = VectorLine.SetRay3D
						(Color.red, orientation.origin, orientation.direction*trajectory.distance);
					
					if(Input.GetMouseButtonDown(0)|| Input.GetButtonDown("SelectBeam"))
					{
						questionGenerator.createQuestion(plsLast.tag);
						questioning = true;
					}
				}
				else
				{
					currentTarget = orientation.origin+orientation.direction*maxLineLength;
					line = VectorLine.SetRay3D
						(Color.yellow, orientation.origin, orientation.direction*maxLineLength);
				}
			}
			else
			{
				currentTarget = orientation.origin+orientation.direction*maxLineLength;
				line = VectorLine.SetRay3D
					(Color.yellow, orientation.origin, orientation.direction*maxLineLength);
			}
		}
		else if(selectionState == 2)
		{
			if(Physics.Raycast(orientation, out trajectory, maxLineLength, flowerSelectionMask))
			{
				plsLast = trajectory.collider.gameObject;
				pls = plsLast.GetComponentInParent<Parametric_L_System>();
				if(!pls.flowersSelected && pls.stopAnimating())
				{
					currentTarget = orientation.origin+orientation.direction*trajectory.distance;
					line = VectorLine.SetRay3D
						(Color.red, orientation.origin, orientation.direction*trajectory.distance);
					
					if(Input.GetMouseButtonDown(0)|| Input.GetButtonDown("SelectBeam"))
					{
						questionGenerator.createQuestion(plsLast.tag);
						questioning = true;
					}
				}
				else
				{
					currentTarget = orientation.origin+orientation.direction*maxLineLength;
					line = VectorLine.SetRay3D
						(Color.white, orientation.origin, orientation.direction*maxLineLength);
				}
			}
			else
			{
				currentTarget = orientation.origin+orientation.direction*maxLineLength;
				line = VectorLine.SetRay3D
					(Color.white, orientation.origin, orientation.direction*maxLineLength);
			}
		}
		else if (objectivesInventory.IsDescribing())
		{
			if(Physics.Raycast(orientation, out trajectory, maxLineLength, descriptionMask))
			{
				if(descriptionObjective == null)
				{
					if(trajectory.collider.gameObject.tag == "Selected")
					{
						plsLast = trajectory.collider.gameObject.transform.parent.gameObject;
						pls = plsLast.GetComponent<Parametric_L_System>();

						if(pls.stopAnimating())
						{	
							currentTarget = orientation.origin+orientation.direction*trajectory.distance;
							
							line = VectorLine.SetRay3D
								(Color.red, orientation.origin, orientation.direction*trajectory.distance);
							
							if(Input.GetMouseButtonDown(0)|| Input.GetButtonDown("SelectBeam"))
							{
								descriptionObjective = plsLast;
								if(!tutorial)
									L_System_Field.RemoveKilledLSystem(plsLast);
								plsLast.GetComponentInChildren<Parametric_Turtle>().HideLines();
								plsLast.SetActive(false);
							}
						}
						else
						{
							currentTarget = orientation.origin+orientation.direction*maxLineLength;
							line = VectorLine.SetRay3D
								(Color.cyan, orientation.origin, maxLineLength*orientation.direction);
						}
					}
					else
					{
						currentTarget = orientation.origin+orientation.direction*maxLineLength;
						line = VectorLine.SetRay3D
							(Color.cyan, orientation.origin, maxLineLength*orientation.direction);
					}
				}
				else
				{
					currentTarget = orientation.origin+orientation.direction*maxLineLength;
					line = VectorLine.SetRay3D
						(Color.cyan, orientation.origin, maxLineLength*orientation.direction);

					if(Input.GetMouseButtonDown(0)|| Input.GetButtonDown("SelectBeam"))
					{
						plsLast.SetActive(true);
						plsLast.transform.position = trajectory.point;
						plsLast.GetComponentInChildren<Parametric_Turtle>().HideLines();
						descriptionObjective = null;
						//Check for inside drop-off zone, if requirements meet
						//We do that logic in the same place as we check question answers above
						//so we set questioning true whenever an lsys is sat down
						questioning = true;
					}
				}
			}
			else
			{
				currentTarget = orientation.origin+orientation.direction*maxLineLength;
				line = VectorLine.SetRay3D
					(Color.cyan, orientation.origin, maxLineLength*orientation.direction);
			}
		}

		targetNode.transform.position = currentTarget;
		if(Physics.Raycast(orientation, out trajectory, maxLineLength, 1))
			targetNode.transform.position = trajectory.point;

		if(tutorial)
		{
			if(questioning)
			{
				questioning = false;
				if(selectionState == 3)
				{}
				else
				{
					SendMessageUpwards("displayLesson", plsLast.tag); 	//During tutorial, intercept the question
					questionGenerator.clearQuestion();					//cancel it and display information
					if(selectionState == 0)
					{
						pls.formSelected = true;
					}
					else if(selectionState == 1)
					{
						pls.leavesSelected = true;
					}
					else if(selectionState == 2)
					{
						pls.flowersSelected = true;
					}
				}
			}
		}
		if(Input.GetButtonDown("BeamChange"))
		{
			if(tutorial)
			{}
			else
			{
				cycleMode();
			}
		}
	}

	public void clearLine()
	{
		VectorLine.Destroy (ref line);
		targetNode.transform.position = Vector3.up * 10000;
	}

	public Vector3 GetCurrentTarget()
	{
		return currentTarget;
	}

	public void InTutorial()
	{
		tutorial = true;
	}

	public void cycleMode()
	{
		selectionState++;
		selectionState = selectionState % 4;
		if((selectionState == 3 && !objectivesInventory.IsDescribing()))
			selectionState = 0;
		if(selectionState > -1 && selectionState < 4)
			questionGenerator.cycleImage(selectionState);
	}

	public void changeCamera()
	{
		VectorLine.SetCamera3D (Camera.main);
	}
}
